1. What is time complexity and what is its relation to algorithms? 
	
	A. Time complexity is a function that estimates the time it takes for a program to execute. We calculate how quickly 
           the time to run the program grows relative to the amount of input we feed into the program.

2. What is runtime?

	A. Runtime is the physical time duration of an algorithm; it is also synonymous with time complexity. 

3. How is the runtime of an algorithm calculated?

	A. To determine runtime or time complexity we calculate how quickly the time to run the program grows relative to the amount of
	input we feed into the program.To determine the time complexity of an algorithm, add up how many instructions the algorithm will 
	execute as a function of the size of its input, then simplify the expression to the largest term and drop any constants. Time 
	complexity is affected by many operations, such as comparisons, loops, and function calls.

4. Name the six types of algorithm growth rates we saw in this checkpoint and list them in order of most efficient to least efficient. 
   Now Google another algorithmic growth rate not covered and place it in the correct spot in your list.

  A.  The six types of growth rates are constant growth, logarithmic Growth, Linear Growth, log-linear growth rate, quadratic growth rate
	and exponential growth rate. In order from most efficient to least efficient:

	1. Constant Growth Rate ----> O(1)
  	2. Logarithmic Growth Rate ----> O(log n)
	3. Linear Growth Rate ----> O(n)
	4. Log-Linear Growth Rate ----> O(n log n)
	5. Quadratic Growth Rate ---->  O(n^2)
	6. Exponential Growth Rate ---->  O(2^n)

	another growth rate not covered would be the Cubed growth rate which would sit between Quadratic and Exponential
	changing the list in order from mose efficient to least efficient as follows:
	
	1. Constant Growth Rate ----> O(1)
  	2. Logarithmic Growth Rate ----> O(log n)
	3. Linear Growth Rate ----> O(n)
	4. Log-Linear Growth Rate ----> O(n log n)
	5. Quadratic Growth Rate ---->  O(n^2)
	6. Cubic Growth Rate ---->  O(n^3)
	7. Exponential Growth Rate ---->  O(2^n)

5. Choose one of the algorithmic growth rates from the last question and make a comparison to a real-life situation.

	A. I believe an easy real life comparison to make would be with Linear Growth Rate. Linear Growth Rate by defination is 
	an algorithm whose performance will grow linearly and in direct proportion to the size of the input data set (O(n)). 
	So lets say we have a savings account with 1,000 dollars in the account. The account has a set interest of $20 year over year.
	we could chart this by showing the Linear growth rate. 

6. Determine the time complexity of the following snippet of code. It is commonly known as a linear search.

FUNCTION linearSearch(array, target)
 FOR each number in the array
   IF number = target THEN
     RETURN true
   END IF
 END FOR
 RETURN false
END FUNCTION



A. this would be Linear Growth Rate O(n), example below 

function linearSearch(array, toFind){
  for(let i = 0; i < array.length; i++){
    if(array[i] === toFind) return i;
  }
  return -1;
}

7. Determine the time complexity of the following snippet of code.

If you get stuck, read through the graphical representation section again.

FUNCTION foo(array)
 FOR each number in the array
   FOR each number in the array
     print "Hello"
   END FOR
 END FOR
END FUNCTION

A. This would be Quadratic Growth Rate O(n^2). example equation shown below:

  var hasDuplicates = function(array) {
  for (var i = 0; i < array.length; i++) {
    var item = array[i];
    if (array.slice(i + 1).indexOf(item) !== -1) {
      return true;
    }
  }
  return false;
};


8. Determine the time complexity of the following snippet of code. It is commonly known as the Fibonacci sequence.

FUNCTION fibonacci(number)
 IF number < 1 THEN
   ERROR
 ELSE IF number = 1 or 2 THEN
   RETURN 1
 ELSE
   CALL fibonacci WITH number - 2 RETURNING twoBack
   CALL fibonacci WITH number - 1 RETURNING oneBack
   RETURN twoBack + oneBack
 END IF
END FUNCTION


A. To solve this i beleive the best approach would be Liniar growth rate O(n). Please see example below

function fibonacci(num){
  var a = 1, b = 0, temp;

  while (num >= 0){
    temp = a;
    a = a + b;
    b = temp;
    num--;
  }

  return b;
}

9. Out of the code snippets you just saw, which is the most time efficient?

A. From the examples I have looked at when researching this section I believe that the most time efficient is Liniar search. When looking
at the above problem for example, Liniar search stayed constatn with Space, and took the least amount of time to run. 