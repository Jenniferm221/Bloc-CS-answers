1. Write pseudocode for bubble sort.

A. 

FUNCTION bubbleSort(collection)
   REPEAT
     SET swapped to false
     FOR i = FIRST INDEX of collection to LAST INDEX of collection - 1
       # #3
       IF collection[i] > collection[i + 1] THEN
         SET tmp to collection[i]
         SET collection[i] to collection[i + 1]
         SET collection[i + 1] to tmp
         SET swapped to true
       END IF
     END FOR
   UNTIL swapped is FALSE

   RETURN collection
 END FUNCTION

2. Write pseudocode for quicksort.

A. 

FUNCTION quickSort(collection)
  SET low to 0
  SET high to collection -1
    IF low < high THEN
        SET pivot to partition WITH collection, low ,high
        CALL quickSort WITH collection, low, pivot
        CALL quickSort WITH collection, pivot + 1, high
    END IF
END FUNCTION

FUNCTION partition(collection, low, high){
     SET pivot to collection[low]
     SET leftwall to low

     FOR each item in collection
         IF collection[i] < pivot THEN
             swap collection[i] with collection[leftwall + 1]
             SET leftwall to leftwall + 1
         END IF
     END FOR
     swap WITH pivot, collection[leftwall]

    RETURN leftwall

3.We talked about time complexity in a previous checkpoint, and how to get an idea of the efficiency of an algorithm. After looking at the 
 pseudocode for the abovesorting methods, identify why merge sort and quick sort are much more efficient than the others. Walking through 
 each algorithm with a few sample collections may help.

A. I believe that merge sort is a efficient algorithm because it can handle large collection without having to iterate through the same 
 collection time and time again. It divides the collection into  sub-collections and then merge them together in order. 

4.All of the sorts addressed in this checkpoint are known as comparison sorts. Research bucket sort and explain how it works. What is 
 the ideal input for bucket sort?

A. Bucket sort starts with an unsorted array, we then set up an array of empty buckets and depending on the items’ range we place them 
into the buckets. Finally we sort the items in the buckets, and we then we place them back into the original array. Bucket sort works best 
when the data are more or less uniformly distributed or where there is an intelligent way to choose the buckets given a quick set of 
heuristics based on the input array